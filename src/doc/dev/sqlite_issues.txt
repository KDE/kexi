---------------------------------------------------------
 SQLITE DRIVER IDEAS, ISSUES, PROPOSALS
 Copyright (C) 2003 Jaroslaw Staniek js at iidea dot pl
 Started: 2003-07-09
 Kexi home page: http://www.koffice.org/kexi/
---------------------------------------------------


1. In most situations (especially on massive data operations) we do not want get types of the columns,
so:

PRAGMA show_datatypes = OFF;


2. SQLite automatically adds primary key to the table if there is no such key. 
Such pkey column is not visible for statemets like 'select * from table', 
'select oid,* from table' need to be executed to also get this special column.

See section '3.1 The ROWID of the most recent insert' of c_interface.html file.


3. For smaller tables (how small? -- add configuration for this) sqlite_get_table() 'in memory'
function could be used to speed up rows retrieving.


4. Queries entered by user in the Query Designer should be checked for syntactically or logically validity and transformed to SQLite-compatible form befor execution. It is nonsense to ask SQLite engine if the given sql statement is valid, because then we wouldn't show too detailed error message to the user.


5. SQLite not only doesn't handles column types but also doesn't checks value sizes, eg. it is possible to insert string of length 100 to the column of size 20.
These checks should be made in KexiDB SQLite engine driver. In fact for each driver these checks could be made because user wants get a descriptive, localized, friendly message what's wrong. No single engine provides this of course. We need to store such a parameters like field size in project meta-data as sqlite doesn't stores that in any convenient way. It stores only 'CREATE TABLE' statement, as is.


6. Possible storage methods for SQLite database embedded in Kexi project:
	A. Single SQLite-compatible database file (let's name it: .sqlite file)
		- Advantages: Best deal for bigger databases - no need for rewriting data form SQLite file to another,
			fastest open and save times. DB data consumes disk space only once. Other applications that uses SQLite library could also make use of standard format of .sqlite file's contents. Kexi project and data would be easily, defacto, separated, what is considered as good method in DB programming.
		- Disadvantages: User (who may want to transfer a database) need to know that .kexi file doesn't stores his data but .sqlite is for that.

	B. Single SQLite-compatible database file embedded inside Kexi project .kexi file.
		SQLite requires an access to a file in its own (raw) format to be available somewhere in the path. If SQLite storing layer could be patched to adding an option for seek to given file position, sqlite data can be stored after Kexi project data. When sqlite raw data file could be saved after a Kexi project's data, rewriting the project contents should be performed (and this is done quite frequently). So, finally storing both files concatenated during normal operations is risky, costly and difficult to implement cleanly. 
		- Advantages: User do not need to know that there is sqlite used in Kexi as embedded DB engine (and even if there is any sql engine). Transferring just one file between machines means successfully transferring data and project.
		- Disadvantages: lack of everything described as advantages of A. method: difficult and costly open and save operations (unless SQLite storing layer could be patched).

	Extensions and compilations of the both above methods:
		- .sqlite files are really good compressable, so compress option can be added (if not for regular saving, then at least for "Email project & data" or 'Save As' actions. For these actions concatenating the sqlite data with Kexi project's data would be another option convenient from user's point of view.

	CURRENT IMPLEMENTATION: B way is selected with above extensions added to the TODO list.


7. SQLite-builtin views are read-only. So the proposal is not to use them. Here is why:
	We want have rw queries in Kexi if main table in a query is rw.
	<DEFINITION>: Main table T in a query Q is a table that is not at 'many' side of query relations.
	</DEFINITION>
	<Example>: 
	table persons (name varchar, city integer);
	table cities (id integer primary key, name varchar);

	DATA: [Jarek, 1]-------[1, Warsaw]
	                      /
	      [Jakub, 1]-----/

	query: select * from persons, cities
	Now: 'cities' table is the main table (in other words it is MASTER table in this query).
	'cities' table is rw table in this query, while 'persons' table is read-only because it is at 'many' side 
	in persons-cities relation. Modifying cities.id field, appropriate persons.city values in related 
	records will be updated if there is cascade update enabled.
	</Example>
	IDEAS: 
	A) Query result view (table view, forms, etc.) should allow editing fields from 
		main (master) table of this query, so every field object KexiDB::Field should have a method:
		bool KexiDB::Field::isWritable() to allow GUI check if editing is allowed. Look that given field object
		should be allocated for given query independently from the same field allocated for table schema.
		The first field object can disallow editing while the latter can allow editing (because it is 
		component of regular table).
	B) Also add method for QString KexiDB::Field that returns i18n'd message about the reasons 
		of disallowing for editing given field in a context of given query.


----------------------------------------------------------------

HINTS:

PRAGMA table_info(table-name);
For each column in the named table, invoke the callback function 
once with information about that column, including the 
column name, data type, whether or not the column can be NULL, 
and the default value for the column.

